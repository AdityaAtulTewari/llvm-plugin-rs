diff --git a/CMakeLists.txt b/CMakeLists.txt
index a02c2a5..5a79abd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -50,6 +50,10 @@ project(LLVM
   VERSION ${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}
   LANGUAGES C CXX ASM)
 
+if (LLVM_EXPORT_SYMBOLS_FOR_PLUGINS)
+  add_definitions(-DEXPORT_SYMBOLS)
+endif()
+
 set(CMAKE_CXX_STANDARD 14 CACHE STRING "C++ standard to conform to")
 set(CMAKE_CXX_STANDARD_REQUIRED YES)
 set(CMAKE_CXX_EXTENSIONS NO)
diff --git a/include/llvm/IR/PassManager.h b/include/llvm/IR/PassManager.h
index 58591ab..e4a9216 100644
--- a/include/llvm/IR/PassManager.h
+++ b/include/llvm/IR/PassManager.h
@@ -34,6 +34,8 @@
 ///
 //===----------------------------------------------------------------------===//
 
+#pragma warning( disable : 4251 )
+
 #ifndef LLVM_IR_PASSMANAGER_H
 #define LLVM_IR_PASSMANAGER_H
 
@@ -62,6 +64,12 @@
 
 namespace llvm {
 
+#ifdef EXPORT_SYMBOLS
+  #define DLL_API __declspec(dllexport)
+#else
+  #define DLL_API __declspec(dllimport)
+#endif
+
 /// A special type used by analysis passes to provide an address that
 /// identifies that particular analysis pass type.
 ///
@@ -99,8 +107,8 @@ private:
 
 template <typename IRUnitT> AnalysisSetKey AllAnalysesOn<IRUnitT>::SetKey;
 
-extern template class AllAnalysesOn<Module>;
-extern template class AllAnalysesOn<Function>;
+template class DLL_API AllAnalysesOn<Module>;
+template class DLL_API AllAnalysesOn<Function>;
 
 /// Represents analyses that only rely on functions' control flow.
 ///
@@ -151,7 +159,7 @@ private:
 ///     // The analysis has been successfully preserved ...
 ///   }
 /// ```
-class PreservedAnalyses {
+class DLL_API PreservedAnalyses {
 public:
   /// Convenience factory function for the empty preserved set.
   static PreservedAnalyses none() { return PreservedAnalyses(); }
@@ -579,7 +587,7 @@ using FunctionPassManager = PassManager<Function>;
 /// internals (e.g PassInstrumentationAnalysis::ID) for use there if needed.
 /// FIXME: figure out a way to move PassInstrumentationAnalysis into its own
 /// header.
-class PassInstrumentationAnalysis
+class DLL_API PassInstrumentationAnalysis
     : public AnalysisInfoMixin<PassInstrumentationAnalysis> {
   friend AnalysisInfoMixin<PassInstrumentationAnalysis>;
   static AnalysisKey Key;
@@ -1136,8 +1144,8 @@ bool FunctionAnalysisManagerModuleProxy::Result::invalidate(
 
 // Ensure the \c FunctionAnalysisManagerModuleProxy is provided as an extern
 // template.
-extern template class InnerAnalysisManagerProxy<FunctionAnalysisManager,
-                                                Module>;
+template class DLL_API InnerAnalysisManagerProxy<FunctionAnalysisManager,
+                                                 Module>;
 
 /// An analysis over an "inner" IR unit that provides access to an
 /// analysis manager over a "outer" IR unit.  The inner unit must be contained
diff --git a/include/llvm/Support/type_traits.h b/include/llvm/Support/type_traits.h
index b7d48e8..27f44d5 100644
--- a/include/llvm/Support/type_traits.h
+++ b/include/llvm/Support/type_traits.h
@@ -132,11 +132,63 @@ struct is_move_assignable {
     static constexpr bool value = decltype(get((T*)nullptr))::value;
 };
 
-
-// An implementation of `std::is_trivially_copyable` since STL version
+// A close implementation of `std::is_trivially_copyable` since STL version
 // is not equally supported by all compilers, especially GCC 4.9.
 // Uniform implementation of this trait is important for ABI compatibility
 // as it has an impact on SmallVector's ABI (among others).
+// This type trait is not exactly in line with `std::is_trivially_copyable`
+// as we cannot test for exactly what `std::is_trivially_copyable` tests for.
+//
+// `llvm::is_trivially_copyable` checks for the following:
+//   * if `T x(declval<const T&>())` is well formed,
+//     then all of T's copy constructors must be trivial,
+//     and there must be at least one non-deleted copy constructor.
+//   * if `declval<T&>() = declval<const T&>()` is well formed,
+//     then all of T's copy assignment operators must be trivial,
+//     and there must be at least one non-deleted copy assignment operator.
+//   * if `T x(declval<T&&>())` is well formed,
+//     then all of T's move constructors must be trivial,
+//     and there must be at least one non-deleted move constructor
+//   * if `declval<T&>() = declval<T&&>()` is well formed,
+//     then all of T's move assignment operators must be trivial,
+//     and there must be at least one non-deleted move assignment operator.
+//   * One of the above clauses must be satisfied; in other words,
+//     it must be either copy constructible, or copy assignable, or
+//     move constructible, or move assignable.
+//   * T must be trivially destructible
+//
+// whereas `std::is_trivially_copyable` checks for:
+//   all of T's copy constructors, move constructors,
+//   copy assignment operators, and move assignment operators are
+//   trivial or deleted, and at least one of these is non-deleted.
+//
+// in addition to the trivially destructible requirement. As an example,
+// see the following class:
+//
+//   struct foo {
+//     foo(const foo&) = default;
+//     foo& operator=(const volatile foo&) = delete;
+//     template <typename T>
+//     foo& operator=(const T&) { return *this; }
+//
+//     foo(foo&&) = delete;
+//     foo& operator=(foo&&) = delete;
+//     ~foo() = default;
+//   };
+//
+// `llvm::is_trivially_copyable<foo>()` is false,
+// since `declval<T&>() = declval<const T&>()` compiles
+// (it finds the template assignment operator),
+// but `foo` has no non-deleted copy assignment operator
+// (a template is never a copy assignment operator).
+//
+// `std::is_trivially_copyable<foo>()` is true,
+// since there are no non-deleted copy assignment operators,
+// and there is a non-deleted trivial copy constructor.
+//
+// This difference is important, since:
+//   * `std::is_trivially_copyable<pair<int, int>>`, but
+//   * `!llvm::is_trivially_copyable<pair<int, int>>`
 template <typename T>
 class is_trivially_copyable {
 
@@ -176,11 +228,6 @@ class is_trivially_copyable {
       (has_deleted_move_constructor || has_trivial_move_constructor) &&
       (has_deleted_copy_assign || has_trivial_copy_assign) &&
       (has_deleted_copy_constructor || has_trivial_copy_constructor);
-
-#ifdef HAVE_STD_IS_TRIVIALLY_COPYABLE
-  static_assert(value == std::is_trivially_copyable<T>::value,
-                "inconsistent behavior between llvm:: and std:: implementation of is_trivially_copyable");
-#endif
 };
 template <typename T>
 class is_trivially_copyable<T*> : public std::true_type {
